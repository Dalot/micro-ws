// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"sync"
)

// Ensure, that observerMock does implement observer.
// If this is not the case, regenerate this file with moq.
var _ observer = &observerMock{}

// observerMock is a mock implementation of observer.
//
// 	func TestSomethingThatUsesobserver(t *testing.T) {
//
// 		// make and configure a mocked observer
// 		mockedobserver := &observerMock{
// 			getIDFunc: func() string {
// 				panic("mock out the getID method")
// 			},
// 			updateFunc: func(bytes []byte)  {
// 				panic("mock out the update method")
// 			},
// 		}
//
// 		// use mockedobserver in code that requires observer
// 		// and then make assertions.
//
// 	}
type observerMock struct {
	// getIDFunc mocks the getID method.
	getIDFunc func() string

	// updateFunc mocks the update method.
	updateFunc func(bytes []byte)

	// calls tracks calls to the methods.
	calls struct {
		// getID holds details about calls to the getID method.
		getID []struct {
		}
		// update holds details about calls to the update method.
		update []struct {
			// Bytes is the bytes argument value.
			Bytes []byte
		}
	}
	lockgetID  sync.RWMutex
	lockupdate sync.RWMutex
}

// getID calls getIDFunc.
func (mock *observerMock) getID() string {
	if mock.getIDFunc == nil {
		panic("observerMock.getIDFunc: method is nil but observer.getID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockgetID.Lock()
	mock.calls.getID = append(mock.calls.getID, callInfo)
	mock.lockgetID.Unlock()
	return mock.getIDFunc()
}

// getIDCalls gets all the calls that were made to getID.
// Check the length with:
//     len(mockedobserver.getIDCalls())
func (mock *observerMock) getIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockgetID.RLock()
	calls = mock.calls.getID
	mock.lockgetID.RUnlock()
	return calls
}

// update calls updateFunc.
func (mock *observerMock) update(bytes []byte) {
	if mock.updateFunc == nil {
		panic("observerMock.updateFunc: method is nil but observer.update was just called")
	}
	callInfo := struct {
		Bytes []byte
	}{
		Bytes: bytes,
	}
	mock.lockupdate.Lock()
	mock.calls.update = append(mock.calls.update, callInfo)
	mock.lockupdate.Unlock()
	mock.updateFunc(bytes)
}

// updateCalls gets all the calls that were made to update.
// Check the length with:
//     len(mockedobserver.updateCalls())
func (mock *observerMock) updateCalls() []struct {
	Bytes []byte
} {
	var calls []struct {
		Bytes []byte
	}
	mock.lockupdate.RLock()
	calls = mock.calls.update
	mock.lockupdate.RUnlock()
	return calls
}
